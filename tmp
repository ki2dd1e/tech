log_1404
Любой VPN строится на инкапсуляции, т.е. на создании туннеля (общей сети) между 2 локальными сетями через некоторую общую сеть (типа Интернет).
Так, создается виртуальный интерфейс типа dev tun с IP-адресом из VPN-сети, выделяется клиентский VPN-пул.
Маршруты по умолчанию 0.0.0.0 должны быть "завернуты" в туннель, то есть весь клиентский трафик обязан проходить через VPN-сервер.
Так же добавляются сертификаты и ключи для обеспечения шифрования.

Виртуальный интерфейс tun работает на 3 уровне и исп. для передачи IP-пакетов. Интерфейс tap работает на 2 уровне и позволяет эмулировать VPN как реальный LAN.

Remote Access VPN предполагает доп. интерфейс на VPN-сервере из подсети защищаемого ресурса. 
На VPN-сервере необходимо, чтобы весь трафик из VPN-сети, приходящий на туннельный интерфейс, был завернут в подсеть защищаемого ресурса (то есть был адресован на интерфейс защищаемого ресурса).
Фаервол должен пропускать пакеты из VPN-сети на адрес защищаемого ресурса.
Также можно настроить NAT адресацию из VPN пула адресов клиентов в единственный адрес на доп. интерфейсе из защищаемой сети.

Обратная маршрутизация. Если некое устройство, получив пакет (допустим, ICMP), может принять его и увидеть поля dest:1.1.1.1, src:2.2.2.1, но отправить не может, если находится в сети 2.2.2.0, то это значит,
что нужна обратная маршрутизация до сети 1.1.1.0 через шлюз этого интерфейса.

Проброс портов - перенаправление (forwarding) трафика, который был адресован на один порт, на другой порт. 
Фактически, это NAT, где обращение на один порт (допустим, внешнего клиента) перенаправляется на другой порт.
iptables -t nat -A PREROUTING -p tcp --dst $GATE --dport $PORT -j DNAT --to-destination $SERVER:$PORT

log_1227
Предположим, есть веб-сервер singapore (команда python для имитации: `python3 -m http.server --bind 192.168.62.57 8001 --directory /tmp &`), который необходимо защитить.  
Создадим прокси-сервер manchester с помощью Nginx в минимальной конфигурации:  
```
events {
    worker_connections 1024;
}
http {
    upstream proxy {
        server 192.168.62.224:8000; #группа бекенд-серверов для балансировки нагрузки
    }
    server {
        listen 8000; #Nginx слушает свой сетевой интерфейс 8000
        server_name <имя сервера с IP 192.168.62.224>; #целевой ресурс, на который "смотрят" все бекенд-серверы

        location / {
            proxy_pass http://proxy; #куда проксировать запросы
        }
    }
}
```
В данной конфигурации есть проблема - при обращении по адресу самого веб-сервера, клиент минует прокси-сервер.  При этом, если бекенд и прокси на разных серверах, то использовать настройку `server 127.0.0.1:8000` для обращения только на Nginx не получится.  Поэтому, для создания доступа только через прокси, создадим правила iptables на веб-сервере.  
Сама утилита iptables проверяет пакеты по критериям из таблиц Filter (фильтрация пакетов), NAT (настройка NAT), Mangle (спец. обработка), Raw (обход системы отслеживания состояний), где каждая таблица состоит из цепочек (послед. правил):  
INPUT (входящие пакеты), FORWARD (проходящие пакеты), OUTPUT (исходящие пакеты).  Для текущей цели пропишем правила, по которому доступ к веб-серверу по порту 8001 будет запрещен для всех машин, кроме прокси, а также разрешим соединение по ssh:  
```
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT
iptables -A INPUT -p tcp --dport 8001 -s 192.168.62.54 -j ACCEPT
iptables -A OUTPUT -p tcp --sport 8001 -s 192.168.62.54 -j ACCEPT
iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
iptables -P INPUT DROP
iptables -P OUTPUT DROP
iptables -P FORWARD DROP
```
Сохраним текущие правила:
`iptables-save > /etc/iptables.rules`
Также нужно ограничить root-доступ по открытому порту 22 посредством конфиг. файла `sshd_config`:
```
PermitRootLogin no
```
При такой настройке, уязвимым становится уже сам прокси-сервер, но запретить все соединения на прокси-сервере не имеет смысла, т.к. он, по своей сути, должен находиться в DMZ и быть доступен для внешних подключений.  
Поэтому, как для любого DMZ-сегмента, необходимо внедрить СЗИ и обеспечить защиту соответствующими настройками, т.к. при незащищенном DMZ злоумышленникам будут доступны практически все возможные сетевые атаки.

log_1715
Развертывание Удостоверяющего Центра на базе OpenSSL начинается с копирования openssl.cnf в директорию будущего CA и редактированием параметров в CA_default:
```
[ CA_default ]

dir             = /root/ca              # корневой каталог CA для хранения файлов
certs           = /root/ca/certs            # каталог для хранения выданных сертификатов
crl_dir         = /root/ca/crl              # каталог для CRL
database        = /root/ca/index.txt        # файл в качестве БД сертификатов
new_certs_dir   = /root/ca/newcerts         # каталог для копирования новых сертификатов после подписи

certificate     = /root/ca/cacert.pem       # путь к корневому сертификату CA (публичный ключ)
serial          = /root/ca/serial           # серийный номер корневого сертификата
crlnumber       = /root/ca/crlnumber        # порядковый номер текущего списка CRL
crl             = /root/ca/crl.pem          # файл текущего CRL
private_key     = /root/ca/private/cakey.pem# путь к закрытому ключу CA

x509_extensions = cert_ext              # раздел в данном конфиг. файле с описанием расширений сертификата (...)

default_days    = 365                   # срок действия сертификатов
default_crl_days= 30                    # срок действия выпущенного списка CRL
default_md      = default               # алгоритм хеширования для подписи и CRL

policy          = policy_any          # политика PKI (отдельный раздел policy_any)
```
Настройки политик вынесены в `policy_any` (стандартные значения):
```
[ policy_any ]
countryName             = optional
stateOrProvinceName     = optional
organizationName        = optional
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
```

log_1011
ARP таблица имеет вид (Linux):
(192.168.62.25) at 74:56:3c:e4:3c:30
При получении пакета на интерфейс, машина записывает в ARP таблицу MAC и IP адреса отправителя. Эта таблица далее используется для маршрутизации на L2.
Таблица маршрутизации в Linux (ip route):
192.168.62.0/24 dev ens192 proto kernel scope link src 192.168.62.224
Пакет с адресом назначения из сети 192.168.62.0/24 будет направлен на интерфейс ens192.
Для отправки пакета, маршрутизатор сверяется с таблицей маршрутизации, чтобы отправить пакет на нужный интерфейс:
если пакет имеет dest: 192.168.62.X/24, то он будет перенаправлен на интерфейс ens192. Далее ARP таблица дает MAC адрес данного IP адреса для маршрутизации на L2.
Если в полученном пакете MAC-адрес получателя неизвестен, машина выполняет ARP-запрос.
Если это хост, то машина берет MAC адрес получателя из ARP таблицы и отправляет пакет на тот же интерфейс.
Отправление пакета на другой интерфейс другой подсети возможно только при включенном форвардинге на роутере или, если это обычный хост.
